/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.serialization.js.ast;

option java_outer_classname = "JsAstProtoBuf";
option optimize_for = LITE_RUNTIME;

// Expressions
//

message Expression {
    oneof expression {
        ThisLiteral thisLiteral = 2;
        NullLiteral nullLiteral = 3;
        TrueLiteral trueLiteral = 4;
        FalseLiteral falseLiteral = 5;
        StringLiteral stringLiteral = 6;
        RegExpLiteral regExpLiteral = 7;
        IntLiteral intLiteral = 8;
        DoubleLiteral doubleLiteral = 9;
        ArrayLiteral arrayLiteral = 10;
        ObjectLiteral objectLiteral = 11;
        Function function = 12;
        DocComment docComment = 13;
        BinaryOperation binary = 14;
        UnaryOperation unary = 15;
        Conditional conditional = 16;
        ArrayAccess arrayAccess = 17;
        NameReference nameReference = 18;
        PropertyReference propertyReference = 19;
        Invocation invocation = 20;
        Instantiation instantiation = 21;
    }
}

message ThisLiteral {
}

message NullLiteral {
}

message TrueLiteral {
}

message FalseLiteral {
}

message StringLiteral {
    required int32 stringId = 1;
}

message RegExpLiteral {
    required int32 patternStringId = 1;
    optional int32 flagsStringId = 2;
}

message IntLiteral {
    required int32 value = 1;
}

message DoubleLiteral {
    required double value = 1;
}

message ArrayLiteral {
    repeated Expression element = 1;
}

message ObjectLiteral {
    repeated ObjectLiteralEntry entry = 1;
}

message ObjectLiteralEntry {
    required Expression key = 1;
    required Expression value = 2;
}

message Function {
    repeated Parameter parameter = 1;
    optional int32 nameId = 2;
    required Statement body = 3;
}

message Parameter {
    required int32 nameId = 1;
}

message DocComment {
    required string text = 1;
}

message BinaryOperation {
    required Expression left = 1;
    required Expression right = 2;
    required Type type = 3;

    enum Type {
        MUL = 1;
        DIV = 2;
        MOD = 3;
        ADD = 4;
        SUB = 5;
        SHL = 6;
        SHR = 7;
        SHRU = 8;
        LT = 9;
        LTE = 10;
        GT = 11;
        GTE = 12;
        INSTANCEOF = 13;
        IN = 14;
        EQ = 15;
        NEQ = 16;
        REF_EQ = 17;
        REF_NEQ = 18;
        BIT_AND = 19;
        BIT_XOR = 20;
        BIT_OR = 21;
        AND = 22;
        OR = 23;
        ASG = 24;
        ASG_ADD = 25;
        ASG_SUB = 26;
        ASG_MUL = 27;
        ASG_DIV = 28;
        ASG_MOD = 29;
        ASG_SHL = 30;
        ASG_SHR = 31;
        ASG_SHRU = 32;
        ASG_BIT_AND = 33;
        ASG_BIT_OR = 34;
        ASG_BIT_XOR = 35;
        COMMA = 36;
    }
}

message UnaryOperation {
    required Expression operand = 1;
    required Type type = 2;
    required bool postfix = 3;

    enum Type {
        BIT_NOT = 1;
        DEC = 2;
        DELETE = 3;
        INC = 4;
        NEG = 5;
        POS = 6;
        NOT = 7;
        TYPEOF = 8;
        VOID = 9;
    }
}

message Conditional {
    required Expression testExpression = 1;
    required Expression thenExpression = 2;
    required Expression elseExpression = 3;
}

message ArrayAccess {
    required Expression array = 1;
    required Expression index = 2;
}

message NameReference {
    required int32 nameId = 1;
    optional Expression qualifier = 2;
}

message PropertyReference {
    required int32 stringId = 1;
    optional Expression qualifier = 2;
}

message Invocation {
    required Expression qualifier = 1;
    repeated Expression argument = 2;
}

message Instantiation {
    required Expression qualifier = 1;
    repeated Expression argument = 2;
}



// Statements
//

message Statement {
    oneof statement {
        Return returnStatement = 1;
        Throw throwStatement = 2;
        Break breakStatement = 3;
        Continue continueStatement = 4;
        Debugger debugger = 5;
        ExpressionStatement expression = 6;
        Vars vars = 7;
        Block block = 8;
        GlobalBlock globalBlock = 9;
        Label label = 10;
        If ifStatement = 11;
        Switch switchStatement = 12;
        While whileStatement = 13;
        DoWhile doWhileStatement = 14;
        For forStatement = 15;
        ForIn forInStatement = 16;
        Try tryStatement = 17;
        Empty empty = 18;
    }
}

message Return {
    optional Expression value = 1;
}

message Throw {
    required Expression exception = 1;
}

message Break {
    optional int32 labelId = 1;
}

message Continue {
    optional int32 labelId = 1;
}

message Debugger {
}

message ExpressionStatement {
    required Expression expression = 1;
}

message Vars {
    repeated VarDeclaration declaration = 1;
}

message VarDeclaration {
    required int32 nameId = 1;
    optional Expression initialValue = 2;
}

message Block {
    repeated Statement statement = 1;
}

message GlobalBlock {
    repeated Statement statement = 1;
}

message Label {
    required int32 nameId = 1;
    required Statement innerStatement = 2;
}

message If {
    required Expression condition = 1;
    required Statement thenStatement = 2;
    optional Statement elseStatement = 3;
}

message Switch {
    required Expression expression = 1;
    repeated SwitchEntry entry = 2;
}

message SwitchEntry {
    optional Expression label = 1;
    repeated Statement statement = 2;
}

message While {
    required Expression condition = 1;
    required Statement body = 2;
}

message DoWhile {
    required Expression condition = 1;
    required Statement body = 2;
}

message For {
    oneof init {
        Vars variables = 1;
        Expression expression = 2;
        EmptyInit empty = 3;
    }
    optional Expression condition = 4;
    optional Expression increment = 5;
    required Statement body = 6;
}

message EmptyInit {
}

message ForIn {
    oneof value {
        int32 nameId = 1;
        Expression expression = 2;
    }
    required Expression iterable = 3;
    required Statement body = 4;
}

message Try {
    required Statement tryBlock = 1;
    optional Catch catchBlock = 2;
    optional Statement finallyBlock = 3;
}

message Catch {
    required Parameter parameter = 1;
    required Statement body = 2;
}

message Empty {
}


// Fragment

message Fragment {
    repeated ImportedModule importedModule = 1;
    repeated Import importEntry = 2;
    optional GlobalBlock declarationBlock = 3;
    optional GlobalBlock exportBlock = 4;
    optional GlobalBlock initializerBlock = 5;
    repeated NameBinding nameBinding = 6;
    repeated ClassModel classModel = 7;
    repeated Expression moduleExpression = 8;
    repeated InlineModule inlineModule = 9;
}

message ImportedModule {
    required int32 externalNameId = 1;
    required int32 internalNameId = 2;
    optional Expression plainReference = 3;
}

message Import {
    required int32 signatureId = 1;
    required Expression expression = 2;
}

message NameBinding {
    required int32 signatureId = 1;
    required int32 nameId = 2;
}

message ClassModel {
    required int32 nameId = 1;
    optional int32 superNameId = 2;
    optional GlobalBlock postDeclarationBlock = 3;
}

message InlineModule {
    required int32 signatureId = 1;
    required int32 expressionId = 2;
}

// Tables
//

message StringTable {
    repeated string entry = 1;
}

message NameTable {
    repeated Name entry = 1;
}

message Name {
    required bool temporary = 1;
    optional string identifier = 2;
}